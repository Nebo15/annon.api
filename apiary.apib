FORMAT: 1A
HOST: http://os-dev-gateway.nebo15.com:8080/

# OrangeSky API Gateway

Keepex - configurable API gateway that allows to pass requests to upstream back-ends and remove from them typical boilerplate that must be re-done everywhere. Inspired by [Kong](https://getkong.org/).

Keepex consist of three main parts:
- Keepex API Gateway - proxy and mutate requests.
- Keepex Dashboard - manage API Gateway settings, review and replay requests from history.
- Keepex - hex package that allows to receive and modify client metadata from Elixir application.
- Keepex Doc - auto-generated documentation based on request history of your API.
- Keepex Status Page - auto-generated status pages on API's. (See: [status.gndf.io](http://status.gndf.io/) for example).

## Goals of the Project

- Provide single management/monitoring system for whole OrangeSky IL.
- Reduce amount of work needed in other componens by orchestrating common functionalities.
- Control response time and get answer "what happened" even in a single request perspective.
- Improve platform scalability.

## General Features

### Caching and Perfomance

For perfomance issues Keepex has build-in cache manager, it will load data from DB only once, all futher work will be based on this cached data.

Whenever a single node receives request that cache has been changed, it's responsible to notify all other nodes in cluster about change, and they should reload configurations from DB.

Whenever new node joins cluster, all other nodes should drop their cache, to resolve consistency issues.

### Cluster Usage

Keepex can automatically discover other nodes in a same private subnetwork. It is archived via [Swarm](https://github.com/bitwalker/swarm) package.

Swarm should be configured to use Kubernetes pod selectors for autoclustering.

### Requests Idempotency

Keepex guarantess that replayed requests with same idempotency key and same data will get same response.

### Request ID's

When receiving request gateway will generate unique `request_id`. 

Optionally, you can send `X-Request-ID` header with your own request id, but you need to make sure that its length not less than 20 characters. Also, if should be unique, or you will receive error response.

## Default Plugins

### Request Logger

By-default, gateway will log all requests and responses by their unique request-id's. You can view find them later in [Request][].

Also, idempotency plug is relies on this logs to send same result for duplicate requests with same `X-Idempotency-Key` headers.

### Monitoring

To monitor services status we will use StatsD integration, that will receive following metrics:

- `request_count` - [API][] hit rate.
- `request_size` - HTTP request size.
- `response_size` - HTTP response size.
- `latency_gateway` - Latency added by API Gateway.
- `latency_upstream` - Latency of upstream API.
- `latency_client_request` - Time elapsed between the first bytes were read from the client and after the last bytes were sent to the client. Useful for detecting slow clients..
- `status_{:http_status_code}_count` - Count of responses grouped by HTTP status code.

<!--
#### HTTPRelay

_TBD v2.0_

Send notification to a multiple upstreams, that is interested in perfoming async workload.

There are several use cases for EventEmitters:

- Notify marketing servervices on customer change/revenue events.
- Notify services about data change, so they can take according actions. (Like sell offer remove.)

Relay request to a multiple back-ends. Useful when you want to send multiple notifications when proxying request itself.

Subsequent requests will 

#### Cache

_TBD v2.0_

Add plugin settings of [API][] to `X-Settings-Cache: json_encode(cache_plugin_setting)` header in all requests to upstream.

#### Circout Breaker

TBD 2.0
-->

### Authorization

All authorization plugins work on top of [Consumers][] entity. Plugins can assign access scopes that can be reused in [ACL][] plugin.
Only one authorization plugin can be enabled at one time, because all of them override [Consumers][] collection logic.

To authorize requests inside private platrom scope we can add `Authroization: Basic base64_token` headers, so services will know that request is sent from API Gateway. _In MVP release we will trust to all requests inside private zone, no API authorization is required._

<!--
#### -oAuth-

_This module will be used only in target architecture releases._

Exchange `user_id` and `user_password` fields that is set in customer plugin settings to a oAuth access token, that can be re-used for futher requests.

Other:

- `user_agent_blacklist` - block requests by HTTP User Agent.
- `cors` - _TBD 2.0_ allow to make requests from browser.
- `ssl` - _TBD 2.0_ add SSL certificate for an API.
- `ratelimit` - _TBD 2.0_ limit how many HTTP requests consumer can make.
- `sizelimit` - _TBD 2.0_ block HTTP requests by body size.
-->

# Group APIs

## Collection [/apis]

You should create a separate API for each of your upstream back-ends. API's are extended by plugins.

It is possible to use `api_name` instead `api_id` in any resource paths.

### Get APIs [GET]

+ Response 200 (application/json)
    + Attributes (CollectionResponse)
        + data (array[API])

### Create API [POST]

+ Request (application/json)
    + Attributes (API)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (API)

+ Response 409 (application/json)
    + Attributes (ErrorResponse)
        + meta (ResponseMeta)
            + code: 409
        + error (ResponseError_DuplicateEntity)

## API [/apis/{api_id}]

### Get API [GET]

+ Parameters
    + api_id: 1 (string)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 200
        + data (API)

### Configure API [PUT]

You can omit any request parameters if you want to parially update API settings.

+ Parameters
    + api_id: 1 (string)

+ Request (application/json)
    + Attributes (API)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 200
        + data (API)

### Delete API [DELETE]

+ Parameters
    + api_id: 1 (string)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)

## Plugins [/apis/{api_id}/plugins]

### Get all plugins binded to an API [GET]

+ Parameters
    + api_id: 1 (string)

+ Response 200 (application/json)
    + Attributes (CollectionResponse)
        + data (array[Plugin])

### Bind plugin to an API [POST]

+ Parameters
    + api_id: 1 (string)

+ Request (application/json)
    + Attributes (Plugin)
        + settings (PluginSettings_Proxy)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (Plugin_Proxy)

### Update Plugin Settings [PUT /apis/{api_id}/plugins/{plugin_name}]

To create plugin you should send whole `Plugin` object, but if plugin already exists you can pass any field to undate only them.

+ Parameters
    + api_id: 1 (string)
    + plugin_name: proxy (string)

+ Request (application/json)
    + Attributes (Plugin_Proxy)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
        + data (Plugin_Proxy)

### Unbind Plugin [DELETE /apis/{api_id}/plugins/{plugin_name}]

+ Parameters
    + api_id: 1 (string)
    + plugin_name: proxy (string)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)

# Group Plugins

## Proxy [/apis/{api_id}/plugins/proxy]

Proxy allows:
- Send HTTP requests from API to a `upstream`.
- Modify path and trim API-related part from it.
- Add headers to upstream request (for example, to authentificate on back-end behind gateway).
- Proxy `X-Request-ID` header, so all upstream back-ends can log request state with same UUID.

### Bind Proxy Plugin [POST /apis/{api_id}/plugins]

+ Parameters
    + api_id: 1 (string) - API ID.

+ Request (application/json)
    + Attributes (Plugin_Proxy)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (Plugin_Proxy)

### Change Proxy Config [PUT]

+ Parameters
    + api_id: 1 (string) - API ID.

+ Request (application/json)
    + Attributes (Plugin_Proxy)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (Plugin_Proxy)

## oAuth Auntenficiation [/apis/{api_id}/plugins/oauth]

This plugin sends request to an oAuth server that should return scopes that is valid for consumer.

This plugin **DOES NOT** authorize API resources, for this purposes use [ACL plugin][].

But if token is invalid, appropriate error response will be send back to api consumer.

## JWT Authentification [/apis/{api_id}/plugins/jwt]

JWT is a authroization plugin that decodes JWT tokens received from api consumer (with a `signature` field that is set in settings) and extacts `scopes` field from it.

This plugin **DOES NOT** authorize API resources, for this purposes use [ACL plugin][].

But if token is invalid, appropriate error response will be send back to api consumer.

### JWT Plugin [PUT /apis/{api_id}/plugins/jwt]

## ACL [/apis/{api_id}/plugins/acl]

ACL allows to protect your API's (or proxy `upstreams`) by a scope-based authorization.

Once enabled it will read `scopes` from any authentification plugin (eg. `JWT`). If there are no scopes, it will send responses with `unathorized` status.

If path is not defined (gateway can not extract list of scopes needed for path), unathorized response is sent.

Proxy configuration consist of pattern matches on request method and path:

```
rules: [
    {path: "^/api/v1/*$", scopes: ["request_api"]},
    {path: "GET /api/v1/profile", scopes: ["read_profile"]},
    {path: "POST,PUT /api/v1/profile", scopes: ["update_profile"]},
    {path: "DELETE /api/v1/profile", scopes: ["delete_profile"]}
]
```

All rules is applied in a order they were defined.

### ACL Plugin [PUT /apis/{api_id}/plugins/acl]

## Validator [/apis/{api_id}/plugins/validator]

Validator plugin allows to set a JSON Schema to validate request to a API by pattern mathching request path:

```
rules: [
    {path: "^/api/v1/*$", schema: "json_schema"},
    {path: "GET /api/v1/profile", schema: "json_schema"}
]
```

### Validator Plugin [PUT /apis/{api_id}/plugins/validator]

## Idempotency [/apis/{api_id}/plugins/idempotency]

Gateway supports idempotency for safely retrying requests without accidentally performing the same operation twice. 

To perform an idempotent request, attach a unique key to any POST request made to the API via the `X-Idempotency-Key: <key>` header.

Gateway always send back the same response for requests made with the same key. However, you cannot use the same key with different request parameters. <!-- The keys expire after 24 hours. -->

### Idempotency Plugin [PUT /apis/{api_id}/plugins/idempotency]

## IP Restriction [/apis/{api_id}/plugins/ip_restriction]

Whitelist or blacklist IP ranges from accessing an API.

### IP Restriction Plugin [PUT /apis/{api_id}/plugins/ip_restriction]

<!--
# Group Consumers

You need to create `Consumer` whenever you want to apply individual plugin settings to a authorized API consumer.

## Collection [/consumers]

### Get Consumers [GET]

+ Request
    + Attributes
        + id
        + external_id
        + metadata
            + key: value

+ Response 200 (application/json)
    + Attributes (CollectionResponse)
        + data (array[Consumer])

### Create Consumer [POST]

+ Request (application/json)
    + Attributes (API)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (Consumer)

## Consumer [/consumers/{external_id}]

To make usage easier you can query consumers by their `{external_id}`.

### Update or Create Consumer [PUT]

You can omit any request parameters if you want to parially update API settings.

+ Request (application/json)
    + Attributes (API)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
        + data (Consumer)

+ Response 201 (application/json)
    + Attributes (SuccessResponse)
        + meta (ResponseMeta)
            + code: 201
        + data (Consumer)

### Delete Consumer [DELETE]

+ Response 200 (application/json)
    + Attributes (SuccessResponse)

## Consumer overrides for Plugin Settings [/consumers/{external_id}/plugins/{plugin_name}]

All consumers can have individual plugin settings that will override those set in API.

By default consumer MAY have associated empty settings for each plugin available in system.

### Update Settings [PUT]

+ Request (application/json)
    + Attributes
        + settings: (PluginSettings_Proxy)

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
        + data (Plugin_Proxy)

### Delete Settings Overrides [DELETE]

This is equal to sending an empty object to `Update Settings` endpoint.

+ Response 200 (application/json)
    + Attributes (SuccessResponse)
-->

# Group Requests

## Collection [/requests]

### Get all Requests [GET]

+ Response 200 (application/json)
    + Attributes (CollectionResponse)
        + data (array[LogEntry])

## Request [/requests/{request_id}]

### Get Request [GET]

+ Response 200 (application/json)
    + Attributes (CollectionResponse)
        + data (LogEntry_Expanded)

### Delete Request [DELETE]

+ Response 200 (application/json)
    + Attributes (SuccessResponse)

## Data Structures
<!-- General request and response structures -->
### CollectionResponse
+ meta: (ResponseMeta, fixed-type)
+ data: (array[], fixed-type)
+ paging: (ResponsePagination, fixed-type)

### SuccessResponse
+ meta: (ResponseMeta, fixed-type)
+ data: (object, fixed-type)

### ErrorResponse
+ meta: (ResponseMeta, fixed-type)
+ error: (ResponseError, fixed-type)

### ResponseMeta
+ code: 200 (number) - HTTP response code.

### ResponseError
+ type: type_atom (string) - Atom that represents error type.
+ message: Error description (string) - Human-readable error message. This is for developers, not end-users.

### `ResponseError_DuplicateEntity`
+ type: object_already_exists (string) - Atom that represents error type.
+ message: This API already exists (string) - Human-readable error message. This is for developers, not end-users.

### ResponsePagination
+ limit: 20 (number) - A limit on the number of objects to be returned, between 1 and 100. Default: 50.
+ cursors:
    + `starting_after`: 56c31536a60ad644060041af (string) - A cursor for use in pagination. An object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with `obj_foo`, your subsequent call can include `starting_after=obj_foo` in order to fetch the next page of the list.
    + `ending_before`: 56c31536a60ad644060041aa (string) - A cursor for use in pagination. An object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with `obj_bar`, your subsequent call can include `ending_before=obj_bar` in order to fetch the previous page of the list.
+ has_more: false

<!-- API section -->
### API
+ id: 56c31536a60ad644060041af (string) - Unique ID for API.
+ name: my_api (string) - Unique name for API.
+ request: (APIRequest, fixed-type) - Request description.

### APIRequest
+ method: GET (string) - HTTP request method.
+ scheme: http (string) - HTTP request scheme. May be: `http`, `https`, `amqp`, `ws`.
+ host: `os-dev-gateway.nebo15.com` (string) - DNS address of your API or its IP.
+ port: 80 (number) - Port on which your API recieves requests.
+ path: /andrew/ (string) - Public path to your API.

<!-- API plugins section -->
### Plugin
+ name: myplugin (string) - Plugin name
+ is_enabled: true (boolean) - Flag that shows that plagin is enabled or disabled.
+ settings: (PluginSettings, fixed-type) - Object that describes API plugin settings.

### PluginSettings
+ key: value - A key-value storage for your API plugins.

<!-- Proxy plugin section -->
### `Plugin_Proxy`
+ name: proxy
+ is_enabled: true
+ settings: (PluginSettings_Proxy)

### `PluginSettings_Proxy`
+ Include PluginSettings_ProxyUpstream
<!--+ preserve_host: false (boolean) - Keep HTTP HOST host header when proxying request to an upstream.-->
<!--+ trim_path: true (boolean) - Remove API prefix from path when sending request to upstream. -->

### `PluginSettings_ProxyUpstream`
+ method: GET (string)
+ scheme: https (string) - HTTP request scheme. May be: `http`, `https`, `amqp`, `ws`.
+ host: binlist.net (string) - DNS address of your upstream or its IP.
+ port: 443 (number) - Port on which your upstream recieves requests.
+ path: /json/545708 (string) - Path to your upstream API. You can omit this parameter to preserve path from original request.

<!-- Consumers section -->
### Consumer
+ id: 56c31536a60ad644060041af (string) - Unique ID for consumer generated by API Gateway.
+ external_id: 56c31536a60ad644060041af (string) - Unique ID for consumer.
+ metadata: (Consumer_Metadata) - Attach any metadata to a consumer. For Auth0 it will be written to `app_metadate` field.

### `Consumer_Metadata`
+ key: value (string) - Key-value data attached to a consumer.

<!-- Requests section -->
### LogEntry
+ id: 123 (string)
+ idempotency_key: sdlsjioej (string)
+ created_at: (string) - ISO DateTime
+ api: (API, optional)
+ status_code
+ ip_address

### `LogEntry_Expanded`
+ id: 123 (string)
+ idempotency_key: sdlsjioej (string)
+ created_at: (string) - ISO DateTime
+ api: (API, optional)
+ consumer: (Consumer, optional)
+ status_code: 200 (string)
+ ip_address: 176.106.1.176 (string)
+ request: (LogEntry_Request, fixed-type)
+ response: (LogEntry_Response, fixed-type)
+ latencies
    + gateway
    + upstream
    + client_request

### `LogEntry_Request`
+ method: GET (string)
+ uri: https://example.com/mypath (string)
+ query: (object)
+ headers: (object)
+ body: (object)

### `LogEntry_Response`
+ status_code: 200
+ headers: (object)
+ body: (object)